use futures::{future, stream, Future, Stream};
use hyper;
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use hyper::{Body, Error, HeaderMap, Request, Response, StatusCode};
use log::warn;
use serde_json;
#[allow(unused_imports)]
use std::convert::{TryFrom, TryInto};
use std::io;
use std::marker::PhantomData;
#[allow(unused_imports)]
use swagger;
pub use swagger::auth::Authorization;
use swagger::auth::Scopes;
use swagger::context::ContextualPayload;
use swagger::{ApiError, Has, RequestParser, XSpanIdString};
use url::form_urlencoded;

use crate::header;
#[allow(unused_imports)]
use crate::models;

pub use crate::context;

use crate::{
    AcceptEditgroupResponse, Api, AuthCheckResponse, AuthOidcResponse, CreateAuthTokenResponse,
    CreateContainerAutoBatchResponse, CreateContainerResponse, CreateCreatorAutoBatchResponse,
    CreateCreatorResponse, CreateEditgroupAnnotationResponse, CreateEditgroupResponse,
    CreateFileAutoBatchResponse, CreateFileResponse, CreateFilesetAutoBatchResponse,
    CreateFilesetResponse, CreateReleaseAutoBatchResponse, CreateReleaseResponse,
    CreateWebcaptureAutoBatchResponse, CreateWebcaptureResponse, CreateWorkAutoBatchResponse,
    CreateWorkResponse, DeleteContainerEditResponse, DeleteContainerResponse,
    DeleteCreatorEditResponse, DeleteCreatorResponse, DeleteFileEditResponse, DeleteFileResponse,
    DeleteFilesetEditResponse, DeleteFilesetResponse, DeleteReleaseEditResponse,
    DeleteReleaseResponse, DeleteWebcaptureEditResponse, DeleteWebcaptureResponse,
    DeleteWorkEditResponse, DeleteWorkResponse, GetChangelogEntryResponse, GetChangelogResponse,
    GetContainerEditResponse, GetContainerHistoryResponse, GetContainerRedirectsResponse,
    GetContainerResponse, GetContainerRevisionResponse, GetCreatorEditResponse,
    GetCreatorHistoryResponse, GetCreatorRedirectsResponse, GetCreatorReleasesResponse,
    GetCreatorResponse, GetCreatorRevisionResponse, GetEditgroupAnnotationsResponse,
    GetEditgroupResponse, GetEditgroupsReviewableResponse, GetEditorAnnotationsResponse,
    GetEditorEditgroupsResponse, GetEditorResponse, GetFileEditResponse, GetFileHistoryResponse,
    GetFileRedirectsResponse, GetFileResponse, GetFileRevisionResponse, GetFilesetEditResponse,
    GetFilesetHistoryResponse, GetFilesetRedirectsResponse, GetFilesetResponse,
    GetFilesetRevisionResponse, GetReleaseEditResponse, GetReleaseFilesResponse,
    GetReleaseFilesetsResponse, GetReleaseHistoryResponse, GetReleaseRedirectsResponse,
    GetReleaseResponse, GetReleaseRevisionResponse, GetReleaseWebcapturesResponse,
    GetWebcaptureEditResponse, GetWebcaptureHistoryResponse, GetWebcaptureRedirectsResponse,
    GetWebcaptureResponse, GetWebcaptureRevisionResponse, GetWorkEditResponse,
    GetWorkHistoryResponse, GetWorkRedirectsResponse, GetWorkReleasesResponse, GetWorkResponse,
    GetWorkRevisionResponse, LookupContainerResponse, LookupCreatorResponse, LookupFileResponse,
    LookupReleaseResponse, UpdateContainerResponse, UpdateCreatorResponse, UpdateEditgroupResponse,
    UpdateEditorResponse, UpdateFileResponse, UpdateFilesetResponse, UpdateReleaseResponse,
    UpdateWebcaptureResponse, UpdateWorkResponse,
};

mod paths {
    use lazy_static::lazy_static;

    lazy_static! {
        pub static ref GLOBAL_REGEX_SET: regex::RegexSet = regex::RegexSet::new(vec![
            r"^/v0/auth/check$",
            r"^/v0/auth/oidc$",
            r"^/v0/auth/token/(?P<editor_id>[^/?#]*)$",
            r"^/v0/changelog$",
            r"^/v0/changelog/(?P<index>[^/?#]*)$",
            r"^/v0/container/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/container/lookup$",
            r"^/v0/container/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/container/(?P<ident>[^/?#]*)$",
            r"^/v0/container/(?P<ident>[^/?#]*)/history$",
            r"^/v0/container/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/creator/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/creator/lookup$",
            r"^/v0/creator/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/creator/(?P<ident>[^/?#]*)$",
            r"^/v0/creator/(?P<ident>[^/?#]*)/history$",
            r"^/v0/creator/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/creator/(?P<ident>[^/?#]*)/releases$",
            r"^/v0/editgroup$",
            r"^/v0/editgroup/auto/container/batch$",
            r"^/v0/editgroup/auto/creator/batch$",
            r"^/v0/editgroup/auto/file/batch$",
            r"^/v0/editgroup/auto/fileset/batch$",
            r"^/v0/editgroup/auto/release/batch$",
            r"^/v0/editgroup/auto/webcapture/batch$",
            r"^/v0/editgroup/auto/work/batch$",
            r"^/v0/editgroup/reviewable$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/accept$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/annotation$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/annotations$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture/(?P<ident>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work/(?P<ident>[^/?#]*)$",
            r"^/v0/editor/(?P<editor_id>[^/?#]*)$",
            r"^/v0/editor/(?P<editor_id>[^/?#]*)/annotations$",
            r"^/v0/editor/(?P<editor_id>[^/?#]*)/editgroups$",
            r"^/v0/file/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/file/lookup$",
            r"^/v0/file/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/file/(?P<ident>[^/?#]*)$",
            r"^/v0/file/(?P<ident>[^/?#]*)/history$",
            r"^/v0/file/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/fileset/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/fileset/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/fileset/(?P<ident>[^/?#]*)$",
            r"^/v0/fileset/(?P<ident>[^/?#]*)/history$",
            r"^/v0/fileset/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/release/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/release/lookup$",
            r"^/v0/release/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/release/(?P<ident>[^/?#]*)$",
            r"^/v0/release/(?P<ident>[^/?#]*)/files$",
            r"^/v0/release/(?P<ident>[^/?#]*)/filesets$",
            r"^/v0/release/(?P<ident>[^/?#]*)/history$",
            r"^/v0/release/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/release/(?P<ident>[^/?#]*)/webcaptures$",
            r"^/v0/webcapture/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/webcapture/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/webcapture/(?P<ident>[^/?#]*)$",
            r"^/v0/webcapture/(?P<ident>[^/?#]*)/history$",
            r"^/v0/webcapture/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/work/edit/(?P<edit_id>[^/?#]*)$",
            r"^/v0/work/rev/(?P<rev_id>[^/?#]*)$",
            r"^/v0/work/(?P<ident>[^/?#]*)$",
            r"^/v0/work/(?P<ident>[^/?#]*)/history$",
            r"^/v0/work/(?P<ident>[^/?#]*)/redirects$",
            r"^/v0/work/(?P<ident>[^/?#]*)/releases$"
        ])
        .expect("Unable to create global regex set");
    }
    pub(crate) static ID_AUTH_CHECK: usize = 0;
    pub(crate) static ID_AUTH_OIDC: usize = 1;
    pub(crate) static ID_AUTH_TOKEN_EDITOR_ID: usize = 2;
    lazy_static! {
        pub static ref REGEX_AUTH_TOKEN_EDITOR_ID: regex::Regex =
            regex::Regex::new(r"^/v0/auth/token/(?P<editor_id>[^/?#]*)$")
                .expect("Unable to create regex for AUTH_TOKEN_EDITOR_ID");
    }
    pub(crate) static ID_CHANGELOG: usize = 3;
    pub(crate) static ID_CHANGELOG_INDEX: usize = 4;
    lazy_static! {
        pub static ref REGEX_CHANGELOG_INDEX: regex::Regex =
            regex::Regex::new(r"^/v0/changelog/(?P<index>[^/?#]*)$")
                .expect("Unable to create regex for CHANGELOG_INDEX");
    }
    pub(crate) static ID_CONTAINER_EDIT_EDIT_ID: usize = 5;
    lazy_static! {
        pub static ref REGEX_CONTAINER_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/container/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for CONTAINER_EDIT_EDIT_ID");
    }
    pub(crate) static ID_CONTAINER_LOOKUP: usize = 6;
    pub(crate) static ID_CONTAINER_REV_REV_ID: usize = 7;
    lazy_static! {
        pub static ref REGEX_CONTAINER_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/container/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for CONTAINER_REV_REV_ID");
    }
    pub(crate) static ID_CONTAINER_IDENT: usize = 8;
    lazy_static! {
        pub static ref REGEX_CONTAINER_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/container/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for CONTAINER_IDENT");
    }
    pub(crate) static ID_CONTAINER_IDENT_HISTORY: usize = 9;
    lazy_static! {
        pub static ref REGEX_CONTAINER_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/container/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for CONTAINER_IDENT_HISTORY");
    }
    pub(crate) static ID_CONTAINER_IDENT_REDIRECTS: usize = 10;
    lazy_static! {
        pub static ref REGEX_CONTAINER_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/container/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for CONTAINER_IDENT_REDIRECTS");
    }
    pub(crate) static ID_CREATOR_EDIT_EDIT_ID: usize = 11;
    lazy_static! {
        pub static ref REGEX_CREATOR_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/creator/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for CREATOR_EDIT_EDIT_ID");
    }
    pub(crate) static ID_CREATOR_LOOKUP: usize = 12;
    pub(crate) static ID_CREATOR_REV_REV_ID: usize = 13;
    lazy_static! {
        pub static ref REGEX_CREATOR_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/creator/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for CREATOR_REV_REV_ID");
    }
    pub(crate) static ID_CREATOR_IDENT: usize = 14;
    lazy_static! {
        pub static ref REGEX_CREATOR_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/creator/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for CREATOR_IDENT");
    }
    pub(crate) static ID_CREATOR_IDENT_HISTORY: usize = 15;
    lazy_static! {
        pub static ref REGEX_CREATOR_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/creator/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for CREATOR_IDENT_HISTORY");
    }
    pub(crate) static ID_CREATOR_IDENT_REDIRECTS: usize = 16;
    lazy_static! {
        pub static ref REGEX_CREATOR_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/creator/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for CREATOR_IDENT_REDIRECTS");
    }
    pub(crate) static ID_CREATOR_IDENT_RELEASES: usize = 17;
    lazy_static! {
        pub static ref REGEX_CREATOR_IDENT_RELEASES: regex::Regex =
            regex::Regex::new(r"^/v0/creator/(?P<ident>[^/?#]*)/releases$")
                .expect("Unable to create regex for CREATOR_IDENT_RELEASES");
    }
    pub(crate) static ID_EDITGROUP: usize = 18;
    pub(crate) static ID_EDITGROUP_AUTO_CONTAINER_BATCH: usize = 19;
    pub(crate) static ID_EDITGROUP_AUTO_CREATOR_BATCH: usize = 20;
    pub(crate) static ID_EDITGROUP_AUTO_FILE_BATCH: usize = 21;
    pub(crate) static ID_EDITGROUP_AUTO_FILESET_BATCH: usize = 22;
    pub(crate) static ID_EDITGROUP_AUTO_RELEASE_BATCH: usize = 23;
    pub(crate) static ID_EDITGROUP_AUTO_WEBCAPTURE_BATCH: usize = 24;
    pub(crate) static ID_EDITGROUP_AUTO_WORK_BATCH: usize = 25;
    pub(crate) static ID_EDITGROUP_REVIEWABLE: usize = 26;
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID: usize = 27;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_ACCEPT: usize = 28;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_ACCEPT: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/accept$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_ACCEPT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_ANNOTATION: usize = 29;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATION: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/annotation$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_ANNOTATION");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_ANNOTATIONS: usize = 30;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATIONS: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/annotations$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_ANNOTATIONS");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CONTAINER: usize = 31;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CONTAINER");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID: usize = 32;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT: usize = 33;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/container/(?P<ident>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CREATOR: usize = 34;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CREATOR: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CREATOR");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID: usize = 35;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT: usize = 36;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/creator/(?P<ident>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_CREATOR_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILE: usize = 37;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILE: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILE");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID: usize = 38;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT: usize = 39;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILE_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/file/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILE_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILESET: usize = 40;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILESET: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILESET");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID: usize = 41;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT: usize = 42;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_FILESET_IDENT: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/fileset/(?P<ident>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_FILESET_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_RELEASE: usize = 43;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_RELEASE: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_RELEASE");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID: usize = 44;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT: usize = 45;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/release/(?P<ident>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_RELEASE_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE: usize = 46;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WEBCAPTURE");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID: usize = 47;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT: usize = 48;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/webcapture/(?P<ident>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WORK: usize = 49;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WORK: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WORK");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID: usize = 50;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(
                r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work/edit/(?P<edit_id>[^/?#]*)$"
            )
            .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID");
    }
    pub(crate) static ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT: usize = 51;
    lazy_static! {
        pub static ref REGEX_EDITGROUP_EDITGROUP_ID_WORK_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/editgroup/(?P<editgroup_id>[^/?#]*)/work/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for EDITGROUP_EDITGROUP_ID_WORK_IDENT");
    }
    pub(crate) static ID_EDITOR_EDITOR_ID: usize = 52;
    lazy_static! {
        pub static ref REGEX_EDITOR_EDITOR_ID: regex::Regex =
            regex::Regex::new(r"^/v0/editor/(?P<editor_id>[^/?#]*)$")
                .expect("Unable to create regex for EDITOR_EDITOR_ID");
    }
    pub(crate) static ID_EDITOR_EDITOR_ID_ANNOTATIONS: usize = 53;
    lazy_static! {
        pub static ref REGEX_EDITOR_EDITOR_ID_ANNOTATIONS: regex::Regex =
            regex::Regex::new(r"^/v0/editor/(?P<editor_id>[^/?#]*)/annotations$")
                .expect("Unable to create regex for EDITOR_EDITOR_ID_ANNOTATIONS");
    }
    pub(crate) static ID_EDITOR_EDITOR_ID_EDITGROUPS: usize = 54;
    lazy_static! {
        pub static ref REGEX_EDITOR_EDITOR_ID_EDITGROUPS: regex::Regex =
            regex::Regex::new(r"^/v0/editor/(?P<editor_id>[^/?#]*)/editgroups$")
                .expect("Unable to create regex for EDITOR_EDITOR_ID_EDITGROUPS");
    }
    pub(crate) static ID_FILE_EDIT_EDIT_ID: usize = 55;
    lazy_static! {
        pub static ref REGEX_FILE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/file/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for FILE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_FILE_LOOKUP: usize = 56;
    pub(crate) static ID_FILE_REV_REV_ID: usize = 57;
    lazy_static! {
        pub static ref REGEX_FILE_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/file/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for FILE_REV_REV_ID");
    }
    pub(crate) static ID_FILE_IDENT: usize = 58;
    lazy_static! {
        pub static ref REGEX_FILE_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/file/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for FILE_IDENT");
    }
    pub(crate) static ID_FILE_IDENT_HISTORY: usize = 59;
    lazy_static! {
        pub static ref REGEX_FILE_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/file/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for FILE_IDENT_HISTORY");
    }
    pub(crate) static ID_FILE_IDENT_REDIRECTS: usize = 60;
    lazy_static! {
        pub static ref REGEX_FILE_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/file/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for FILE_IDENT_REDIRECTS");
    }
    pub(crate) static ID_FILESET_EDIT_EDIT_ID: usize = 61;
    lazy_static! {
        pub static ref REGEX_FILESET_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/fileset/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for FILESET_EDIT_EDIT_ID");
    }
    pub(crate) static ID_FILESET_REV_REV_ID: usize = 62;
    lazy_static! {
        pub static ref REGEX_FILESET_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/fileset/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for FILESET_REV_REV_ID");
    }
    pub(crate) static ID_FILESET_IDENT: usize = 63;
    lazy_static! {
        pub static ref REGEX_FILESET_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/fileset/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for FILESET_IDENT");
    }
    pub(crate) static ID_FILESET_IDENT_HISTORY: usize = 64;
    lazy_static! {
        pub static ref REGEX_FILESET_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/fileset/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for FILESET_IDENT_HISTORY");
    }
    pub(crate) static ID_FILESET_IDENT_REDIRECTS: usize = 65;
    lazy_static! {
        pub static ref REGEX_FILESET_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/fileset/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for FILESET_IDENT_REDIRECTS");
    }
    pub(crate) static ID_RELEASE_EDIT_EDIT_ID: usize = 66;
    lazy_static! {
        pub static ref REGEX_RELEASE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/release/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for RELEASE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_RELEASE_LOOKUP: usize = 67;
    pub(crate) static ID_RELEASE_REV_REV_ID: usize = 68;
    lazy_static! {
        pub static ref REGEX_RELEASE_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/release/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for RELEASE_REV_REV_ID");
    }
    pub(crate) static ID_RELEASE_IDENT: usize = 69;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for RELEASE_IDENT");
    }
    pub(crate) static ID_RELEASE_IDENT_FILES: usize = 70;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT_FILES: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)/files$")
                .expect("Unable to create regex for RELEASE_IDENT_FILES");
    }
    pub(crate) static ID_RELEASE_IDENT_FILESETS: usize = 71;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT_FILESETS: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)/filesets$")
                .expect("Unable to create regex for RELEASE_IDENT_FILESETS");
    }
    pub(crate) static ID_RELEASE_IDENT_HISTORY: usize = 72;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for RELEASE_IDENT_HISTORY");
    }
    pub(crate) static ID_RELEASE_IDENT_REDIRECTS: usize = 73;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for RELEASE_IDENT_REDIRECTS");
    }
    pub(crate) static ID_RELEASE_IDENT_WEBCAPTURES: usize = 74;
    lazy_static! {
        pub static ref REGEX_RELEASE_IDENT_WEBCAPTURES: regex::Regex =
            regex::Regex::new(r"^/v0/release/(?P<ident>[^/?#]*)/webcaptures$")
                .expect("Unable to create regex for RELEASE_IDENT_WEBCAPTURES");
    }
    pub(crate) static ID_WEBCAPTURE_EDIT_EDIT_ID: usize = 75;
    lazy_static! {
        pub static ref REGEX_WEBCAPTURE_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/webcapture/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for WEBCAPTURE_EDIT_EDIT_ID");
    }
    pub(crate) static ID_WEBCAPTURE_REV_REV_ID: usize = 76;
    lazy_static! {
        pub static ref REGEX_WEBCAPTURE_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/webcapture/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for WEBCAPTURE_REV_REV_ID");
    }
    pub(crate) static ID_WEBCAPTURE_IDENT: usize = 77;
    lazy_static! {
        pub static ref REGEX_WEBCAPTURE_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/webcapture/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for WEBCAPTURE_IDENT");
    }
    pub(crate) static ID_WEBCAPTURE_IDENT_HISTORY: usize = 78;
    lazy_static! {
        pub static ref REGEX_WEBCAPTURE_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/webcapture/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for WEBCAPTURE_IDENT_HISTORY");
    }
    pub(crate) static ID_WEBCAPTURE_IDENT_REDIRECTS: usize = 79;
    lazy_static! {
        pub static ref REGEX_WEBCAPTURE_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/webcapture/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for WEBCAPTURE_IDENT_REDIRECTS");
    }
    pub(crate) static ID_WORK_EDIT_EDIT_ID: usize = 80;
    lazy_static! {
        pub static ref REGEX_WORK_EDIT_EDIT_ID: regex::Regex =
            regex::Regex::new(r"^/v0/work/edit/(?P<edit_id>[^/?#]*)$")
                .expect("Unable to create regex for WORK_EDIT_EDIT_ID");
    }
    pub(crate) static ID_WORK_REV_REV_ID: usize = 81;
    lazy_static! {
        pub static ref REGEX_WORK_REV_REV_ID: regex::Regex =
            regex::Regex::new(r"^/v0/work/rev/(?P<rev_id>[^/?#]*)$")
                .expect("Unable to create regex for WORK_REV_REV_ID");
    }
    pub(crate) static ID_WORK_IDENT: usize = 82;
    lazy_static! {
        pub static ref REGEX_WORK_IDENT: regex::Regex =
            regex::Regex::new(r"^/v0/work/(?P<ident>[^/?#]*)$")
                .expect("Unable to create regex for WORK_IDENT");
    }
    pub(crate) static ID_WORK_IDENT_HISTORY: usize = 83;
    lazy_static! {
        pub static ref REGEX_WORK_IDENT_HISTORY: regex::Regex =
            regex::Regex::new(r"^/v0/work/(?P<ident>[^/?#]*)/history$")
                .expect("Unable to create regex for WORK_IDENT_HISTORY");
    }
    pub(crate) static ID_WORK_IDENT_REDIRECTS: usize = 84;
    lazy_static! {
        pub static ref REGEX_WORK_IDENT_REDIRECTS: regex::Regex =
            regex::Regex::new(r"^/v0/work/(?P<ident>[^/?#]*)/redirects$")
                .expect("Unable to create regex for WORK_IDENT_REDIRECTS");
    }
    pub(crate) static ID_WORK_IDENT_RELEASES: usize = 85;
    lazy_static! {
        pub static ref REGEX_WORK_IDENT_RELEASES: regex::Regex =
            regex::Regex::new(r"^/v0/work/(?P<ident>[^/?#]*)/releases$")
                .expect("Unable to create regex for WORK_IDENT_RELEASES");
    }
}

pub struct MakeService<T, RC> {
    api_impl: T,
    marker: PhantomData<RC>,
}

impl<T, RC> MakeService<T, RC>
where
    T: Api<RC> + Clone + Send + 'static,
    RC: Has<XSpanIdString> + Has<Option<Authorization>> + 'static,
{
    pub fn new(api_impl: T) -> Self {
        MakeService {
            api_impl,
            marker: PhantomData,
        }
    }
}

impl<'a, T, SC, RC> hyper::service::MakeService<&'a SC> for MakeService<T, RC>
where
    T: Api<RC> + Clone + Send + 'static,
    RC: Has<XSpanIdString> + Has<Option<Authorization>> + 'static + Send,
{
    type ReqBody = ContextualPayload<Body, RC>;
    type ResBody = Body;
    type Error = Error;
    type Service = Service<T, RC>;
    type Future = future::FutureResult<Self::Service, Self::MakeError>;
    type MakeError = Error;

    fn make_service(&mut self, _ctx: &'a SC) -> Self::Future {
        future::FutureResult::from(Ok(Service::new(self.api_impl.clone())))
    }
}

type ServiceFuture = Box<dyn Future<Item = Response<Body>, Error = Error> + Send>;

fn method_not_allowed() -> ServiceFuture {
    Box::new(future::ok(
        Response::builder()
            .status(StatusCode::METHOD_NOT_ALLOWED)
            .body(Body::empty())
            .expect("Unable to create Method Not Allowed response"),
    ))
}

pub struct Service<T, RC> {
    api_impl: T,
    marker: PhantomData<RC>,
}

impl<T, RC> Service<T, RC>
where
    T: Api<RC> + Clone + Send + 'static,
    RC: Has<XSpanIdString> + Has<Option<Authorization>> + 'static,
{
    pub fn new(api_impl: T) -> Self {
        Service {
            api_impl: api_impl,
            marker: PhantomData,
        }
    }
}

impl<T, C> hyper::service::Service for Service<T, C>
where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + 'static + Send,
{
    type ReqBody = ContextualPayload<Body, C>;
    type ResBody = Body;
    type Error = Error;
    type Future = ServiceFuture;

    fn call(&mut self, req: Request<Self::ReqBody>) -> Self::Future {
        let api_impl = self.api_impl.clone();
        let (parts, body) = req.into_parts();
        let (method, uri, headers) = (parts.method, parts.uri, parts.headers);
        let path = paths::GLOBAL_REGEX_SET.matches(uri.path());
        let mut context = body.context;
        let body = body.inner;

        match &method {
            // AcceptEditgroup - POST /editgroup/{editgroup_id}/accept
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ACCEPT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_ACCEPT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_ACCEPT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_ACCEPT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.accept_editgroup(
                                            param_editgroup_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AcceptEditgroupResponse::MergedSuccessfully
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_MERGED_SUCCESSFULLY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::EditConflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_EDIT_CONFLICT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AcceptEditgroupResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ACCEPT_EDITGROUP_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // AuthCheck - GET /auth/check
            &hyper::Method::GET if path.matched(paths::ID_AUTH_CHECK) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_role = query_params
                    .iter()
                    .filter(|e| e.0 == "role")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_role = param_role.and_then(|param_role| param_role.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.auth_check(
                                            param_role,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AuthCheckResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_CHECK_SUCCESS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthCheckResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_CHECK_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthCheckResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_CHECK_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthCheckResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_CHECK_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthCheckResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_CHECK_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // AuthOidc - POST /auth/oidc
            &hyper::Method::POST if path.matched(paths::ID_AUTH_OIDC) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_oidc_params: Option<models::AuthOidc> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_oidc_params) => param_oidc_params,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter oidc_params - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter oidc_params due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_oidc_params = match param_oidc_params {
                                    Some(param_oidc_params) => param_oidc_params,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter oidc_params"))
                                                        .expect("Unable to create Bad Request response for missing body parameter oidc_params"))),
                                };

                                Box::new(
                                    api_impl.auth_oidc(
                                            param_oidc_params,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AuthOidcResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::Created
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_CREATED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_CONFLICT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                AuthOidcResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUTH_OIDC_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter oidc_params: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter oidc_params"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateAuthToken - POST /auth/token/{editor_id}
            &hyper::Method::POST if path.matched(paths::ID_AUTH_TOKEN_EDITOR_ID) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_AUTH_TOKEN_EDITOR_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AUTH_TOKEN_EDITOR_ID in set but failed match against \"{}\"", path, paths::REGEX_AUTH_TOKEN_EDITOR_ID.as_str())
                    );

                let param_editor_id = match percent_encoding::percent_decode(path_params["editor_id"].as_bytes()).decode_utf8() {
                    Ok(param_editor_id) => match param_editor_id.parse::<String>() {
                        Ok(param_editor_id) => param_editor_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editor_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editor_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_duration_seconds = query_params
                    .iter()
                    .filter(|e| e.0 == "duration_seconds")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_duration_seconds = param_duration_seconds
                    .and_then(|param_duration_seconds| param_duration_seconds.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.create_auth_token(
                                            param_editor_id,
                                            param_duration_seconds,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateAuthTokenResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_AUTH_TOKEN_SUCCESS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateAuthTokenResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_AUTH_TOKEN_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateAuthTokenResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_AUTH_TOKEN_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateAuthTokenResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_AUTH_TOKEN_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateAuthTokenResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_AUTH_TOKEN_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // CreateContainer - POST /editgroup/{editgroup_id}/container
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CONTAINER in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::ContainerEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_container(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateContainerResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateContainerAutoBatch - POST /editgroup/auto/container/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_CONTAINER_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::ContainerAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_container_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateContainerAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateContainerAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CONTAINER_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateCreator - POST /editgroup/{editgroup_id}/creator
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CREATOR in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::CreatorEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_creator(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateCreatorResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateCreatorAutoBatch - POST /editgroup/auto/creator/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_CREATOR_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::CreatorAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_creator_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateCreatorAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateCreatorAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_CREATOR_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateEditgroup - POST /editgroup
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_editgroup: Option<models::Editgroup> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_editgroup) => param_editgroup,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter editgroup - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter editgroup due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_editgroup = match param_editgroup {
                                    Some(param_editgroup) => param_editgroup,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter editgroup"))
                                                        .expect("Unable to create Bad Request response for missing body parameter editgroup"))),
                                };

                                Box::new(
                                    api_impl.create_editgroup(
                                            param_editgroup,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateEditgroupResponse::SuccessfullyCreated
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_SUCCESSFULLY_CREATED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter editgroup: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter editgroup"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateEditgroupAnnotation - POST /editgroup/{editgroup_id}/annotation
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATION) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATION
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_ANNOTATION in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATION.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_annotation: Option<models::EditgroupAnnotation> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_annotation) => param_annotation,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter annotation - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter annotation due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_annotation = match param_annotation {
                                    Some(param_annotation) => param_annotation,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter annotation"))
                                                        .expect("Unable to create Bad Request response for missing body parameter annotation"))),
                                };

                                Box::new(
                                    api_impl.create_editgroup_annotation(
                                            param_editgroup_id,
                                            param_annotation,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateEditgroupAnnotationResponse::Created
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_CREATED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupAnnotationResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupAnnotationResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupAnnotationResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupAnnotationResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateEditgroupAnnotationResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_EDITGROUP_ANNOTATION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter annotation: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter annotation"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateFile - POST /editgroup/{editgroup_id}/file
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILE in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::FileEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_file(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateFileResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateFileAutoBatch - POST /editgroup/auto/file/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_FILE_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::FileAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_file_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateFileAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFileAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILE_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateFileset - POST /editgroup/{editgroup_id}/fileset
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILESET in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::FilesetEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_fileset(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateFilesetResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateFilesetAutoBatch - POST /editgroup/auto/fileset/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_FILESET_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::FilesetAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_fileset_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateFilesetAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateFilesetAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_FILESET_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateRelease - POST /editgroup/{editgroup_id}/release
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_RELEASE in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::ReleaseEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_release(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateReleaseResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateReleaseAutoBatch - POST /editgroup/auto/release/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_RELEASE_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::ReleaseAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_release_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateReleaseAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateReleaseAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_RELEASE_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateWebcapture - POST /editgroup/{editgroup_id}/webcapture
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WEBCAPTURE in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::WebcaptureEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_webcapture(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateWebcaptureResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateWebcaptureAutoBatch - POST /editgroup/auto/webcapture/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_WEBCAPTURE_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::WebcaptureAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_webcapture_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateWebcaptureAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWebcaptureAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WEBCAPTURE_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateWork - POST /editgroup/{editgroup_id}/work
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WORK in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::WorkEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.create_work(
                                            param_editgroup_id,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateWorkResponse::CreatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_CREATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // CreateWorkAutoBatch - POST /editgroup/auto/work/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_WORK_BATCH) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_auto_batch: Option<models::WorkAutoBatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_auto_batch) => param_auto_batch,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter auto_batch - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter auto_batch due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_auto_batch = match param_auto_batch {
                                    Some(param_auto_batch) => param_auto_batch,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter auto_batch"))
                                                        .expect("Unable to create Bad Request response for missing body parameter auto_batch"))),
                                };

                                Box::new(
                                    api_impl.create_work_auto_batch(
                                            param_auto_batch,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateWorkAutoBatchResponse::CreatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_CREATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkAutoBatchResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkAutoBatchResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkAutoBatchResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkAutoBatchResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                CreateWorkAutoBatchResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CREATE_WORK_AUTO_BATCH_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter auto_batch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter auto_batch"))),
                        }
                    })
                ) as Self::Future
            }

            // DeleteContainer - DELETE /editgroup/{editgroup_id}/container/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_container(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteContainerResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteContainerEdit - DELETE /editgroup/{editgroup_id}/container/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_container_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteContainerEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteContainerEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CONTAINER_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteCreator - DELETE /editgroup/{editgroup_id}/creator/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CREATOR_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_creator(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteCreatorResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteCreatorEdit - DELETE /editgroup/{editgroup_id}/creator/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_creator_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteCreatorEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteCreatorEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_CREATOR_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteFile - DELETE /editgroup/{editgroup_id}/file/{ident}
            &hyper::Method::DELETE if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_file(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteFileResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteFileEdit - DELETE /editgroup/{editgroup_id}/file/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_file_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteFileEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFileEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteFileset - DELETE /editgroup/{editgroup_id}/fileset/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILESET_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_fileset(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteFilesetResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteFilesetEdit - DELETE /editgroup/{editgroup_id}/fileset/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_fileset_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteFilesetEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteFilesetEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_FILESET_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteRelease - DELETE /editgroup/{editgroup_id}/release/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_RELEASE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_release(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteReleaseResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteReleaseEdit - DELETE /editgroup/{editgroup_id}/release/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_release_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteReleaseEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteReleaseEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_RELEASE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteWebcapture - DELETE /editgroup/{editgroup_id}/webcapture/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_webcapture(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteWebcaptureResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteWebcaptureEdit - DELETE /editgroup/{editgroup_id}/webcapture/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_webcapture_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteWebcaptureEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWebcaptureEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WEBCAPTURE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteWork - DELETE /editgroup/{editgroup_id}/work/{ident}
            &hyper::Method::DELETE if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WORK_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_work(
                                            param_editgroup_id,
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteWorkResponse::DeletedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_DELETED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // DeleteWorkEdit - DELETE /editgroup/{editgroup_id}/work/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.delete_work_edit(
                                            param_editgroup_id,
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteWorkEditResponse::DeletedEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_DELETED_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkEditResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkEditResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                DeleteWorkEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELETE_WORK_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetChangelog - GET /changelog
            &hyper::Method::GET if path.matched(paths::ID_CHANGELOG) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_changelog(
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetChangelogResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_SUCCESS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetChangelogResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetChangelogResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetChangelogEntry - GET /changelog/{index}
            &hyper::Method::GET if path.matched(paths::ID_CHANGELOG_INDEX) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CHANGELOG_INDEX
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CHANGELOG_INDEX in set but failed match against \"{}\"", path, paths::REGEX_CHANGELOG_INDEX.as_str())
                    );

                let param_index = match percent_encoding::percent_decode(path_params["index"].as_bytes()).decode_utf8() {
                    Ok(param_index) => match param_index.parse::<i64>() {
                        Ok(param_index) => param_index,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter index: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["index"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_changelog_entry(
                                            param_index,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetChangelogEntryResponse::FoundChangelogEntry
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_ENTRY_FOUND_CHANGELOG_ENTRY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetChangelogEntryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_ENTRY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetChangelogEntryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_ENTRY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetChangelogEntryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CHANGELOG_ENTRY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetContainer - GET /container/{ident}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CONTAINER_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CONTAINER_IDENT in set but failed match against \"{}\"", path, paths::REGEX_CONTAINER_IDENT.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_container(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetContainerResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetContainerEdit - GET /container/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CONTAINER_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CONTAINER_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_CONTAINER_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_container_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetContainerEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetContainerHistory - GET /container/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CONTAINER_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CONTAINER_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_CONTAINER_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_container_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetContainerHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetContainerRedirects - GET /container/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CONTAINER_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CONTAINER_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_CONTAINER_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_container_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetContainerRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetContainerRevision - GET /container/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CONTAINER_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CONTAINER_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_CONTAINER_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_container_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetContainerRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetContainerRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CONTAINER_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreator - GET /creator/{ident}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_IDENT in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_IDENT.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreatorEdit - GET /creator/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreatorHistory - GET /creator/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreatorRedirects - GET /creator/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreatorReleases - GET /creator/{ident}/releases
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_RELEASES) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_IDENT_RELEASES
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_IDENT_RELEASES in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_IDENT_RELEASES.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator_releases(
                                            param_ident,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorReleasesResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_RELEASES_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorReleasesResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_RELEASES_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorReleasesResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_RELEASES_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorReleasesResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_RELEASES_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetCreatorRevision - GET /creator/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_CREATOR_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CREATOR_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_CREATOR_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_creator_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCreatorRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetCreatorRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_CREATOR_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditgroup - GET /editgroup/{editgroup_id}
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editgroup(
                                            param_editgroup_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditgroupResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditgroupAnnotations - GET /editgroup/{editgroup_id}/annotations
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATIONS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATIONS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_ANNOTATIONS in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_ANNOTATIONS.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editgroup_annotations(
                                            param_editgroup_id,
                                            param_expand,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditgroupAnnotationsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_SUCCESS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupAnnotationsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupAnnotationsResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupAnnotationsResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupAnnotationsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupAnnotationsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUP_ANNOTATIONS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditgroupsReviewable - GET /editgroup/reviewable
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_REVIEWABLE) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());
                let param_before = query_params
                    .iter()
                    .filter(|e| e.0 == "before")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_before = param_before.and_then(|param_before| param_before.parse().ok());
                let param_since = query_params
                    .iter()
                    .filter(|e| e.0 == "since")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_since = param_since.and_then(|param_since| param_since.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editgroups_reviewable(
                                            param_expand,
                                            param_limit,
                                            param_before,
                                            param_since,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditgroupsReviewableResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUPS_REVIEWABLE_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupsReviewableResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUPS_REVIEWABLE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupsReviewableResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUPS_REVIEWABLE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditgroupsReviewableResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITGROUPS_REVIEWABLE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditor - GET /editor/{editor_id}
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITOR_EDITOR_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITOR_EDITOR_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITOR_EDITOR_ID.as_str())
                    );

                let param_editor_id = match percent_encoding::percent_decode(path_params["editor_id"].as_bytes()).decode_utf8() {
                    Ok(param_editor_id) => match param_editor_id.parse::<String>() {
                        Ok(param_editor_id) => param_editor_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editor_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editor_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editor(
                                            param_editor_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditorResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditorAnnotations - GET /editor/{editor_id}/annotations
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID_ANNOTATIONS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITOR_EDITOR_ID_ANNOTATIONS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITOR_EDITOR_ID_ANNOTATIONS in set but failed match against \"{}\"", path, paths::REGEX_EDITOR_EDITOR_ID_ANNOTATIONS.as_str())
                    );

                let param_editor_id = match percent_encoding::percent_decode(path_params["editor_id"].as_bytes()).decode_utf8() {
                    Ok(param_editor_id) => match param_editor_id.parse::<String>() {
                        Ok(param_editor_id) => param_editor_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editor_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editor_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());
                let param_before = query_params
                    .iter()
                    .filter(|e| e.0 == "before")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_before = param_before.and_then(|param_before| param_before.parse().ok());
                let param_since = query_params
                    .iter()
                    .filter(|e| e.0 == "since")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_since = param_since.and_then(|param_since| param_since.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editor_annotations(
                                            param_editor_id,
                                            param_limit,
                                            param_before,
                                            param_since,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditorAnnotationsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_SUCCESS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorAnnotationsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorAnnotationsResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorAnnotationsResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorAnnotationsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorAnnotationsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_ANNOTATIONS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetEditorEditgroups - GET /editor/{editor_id}/editgroups
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID_EDITGROUPS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITOR_EDITOR_ID_EDITGROUPS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITOR_EDITOR_ID_EDITGROUPS in set but failed match against \"{}\"", path, paths::REGEX_EDITOR_EDITOR_ID_EDITGROUPS.as_str())
                    );

                let param_editor_id = match percent_encoding::percent_decode(path_params["editor_id"].as_bytes()).decode_utf8() {
                    Ok(param_editor_id) => match param_editor_id.parse::<String>() {
                        Ok(param_editor_id) => param_editor_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editor_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editor_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());
                let param_before = query_params
                    .iter()
                    .filter(|e| e.0 == "before")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_before = param_before.and_then(|param_before| param_before.parse().ok());
                let param_since = query_params
                    .iter()
                    .filter(|e| e.0 == "since")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_since = param_since.and_then(|param_since| param_since.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_editor_editgroups(
                                            param_editor_id,
                                            param_limit,
                                            param_before,
                                            param_since,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetEditorEditgroupsResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_EDITGROUPS_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorEditgroupsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_EDITGROUPS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorEditgroupsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_EDITGROUPS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetEditorEditgroupsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_EDITOR_EDITGROUPS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFile - GET /file/{ident}
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params = paths::REGEX_FILE_IDENT.captures(&path).unwrap_or_else(|| {
                    panic!(
                        "Path {} matched RE FILE_IDENT in set but failed match against \"{}\"",
                        path,
                        paths::REGEX_FILE_IDENT.as_str()
                    )
                });

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_file(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFileResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFileEdit - GET /file/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_FILE_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_FILE_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_file_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFileEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFileHistory - GET /file/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILE_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILE_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_FILE_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_file_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFileHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFileRedirects - GET /file/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILE_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILE_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_FILE_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_file_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFileRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFileRevision - GET /file/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_FILE_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILE_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILE_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_FILE_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_file_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFileRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFileRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILE_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFileset - GET /fileset/{ident}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILESET_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILESET_IDENT in set but failed match against \"{}\"", path, paths::REGEX_FILESET_IDENT.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_fileset(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFilesetResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFilesetEdit - GET /fileset/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILESET_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILESET_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_FILESET_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_fileset_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFilesetEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFilesetHistory - GET /fileset/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILESET_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILESET_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_FILESET_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_fileset_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFilesetHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFilesetRedirects - GET /fileset/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILESET_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILESET_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_FILESET_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_fileset_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFilesetRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetFilesetRevision - GET /fileset/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_FILESET_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE FILESET_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_FILESET_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_fileset_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFilesetRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetFilesetRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_FILESET_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetRelease - GET /release/{ident}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseEdit - GET /release/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseFiles - GET /release/{ident}/files
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_FILES) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT_FILES
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT_FILES in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT_FILES.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_files(
                                            param_ident,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseFilesResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILES_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILES_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILES_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILES_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseFilesets - GET /release/{ident}/filesets
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_FILESETS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT_FILESETS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT_FILESETS in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT_FILESETS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_filesets(
                                            param_ident,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseFilesetsResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILESETS_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesetsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILESETS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesetsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILESETS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseFilesetsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_FILESETS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseHistory - GET /release/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseRedirects - GET /release/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseRevision - GET /release/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetReleaseWebcaptures - GET /release/{ident}/webcaptures
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_WEBCAPTURES) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_RELEASE_IDENT_WEBCAPTURES
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RELEASE_IDENT_WEBCAPTURES in set but failed match against \"{}\"", path, paths::REGEX_RELEASE_IDENT_WEBCAPTURES.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_release_webcaptures(
                                            param_ident,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReleaseWebcapturesResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_WEBCAPTURES_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseWebcapturesResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_WEBCAPTURES_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseWebcapturesResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_WEBCAPTURES_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetReleaseWebcapturesResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_RELEASE_WEBCAPTURES_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWebcapture - GET /webcapture/{ident}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WEBCAPTURE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WEBCAPTURE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_WEBCAPTURE_IDENT.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_webcapture(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWebcaptureResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWebcaptureEdit - GET /webcapture/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WEBCAPTURE_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WEBCAPTURE_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_WEBCAPTURE_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_webcapture_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWebcaptureEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWebcaptureHistory - GET /webcapture/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WEBCAPTURE_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WEBCAPTURE_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_WEBCAPTURE_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_webcapture_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWebcaptureHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWebcaptureRedirects - GET /webcapture/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WEBCAPTURE_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WEBCAPTURE_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_WEBCAPTURE_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_webcapture_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWebcaptureRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWebcaptureRevision - GET /webcapture/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WEBCAPTURE_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WEBCAPTURE_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_WEBCAPTURE_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_webcapture_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWebcaptureRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWebcaptureRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WEBCAPTURE_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWork - GET /work/{ident}
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params = paths::REGEX_WORK_IDENT.captures(&path).unwrap_or_else(|| {
                    panic!(
                        "Path {} matched RE WORK_IDENT in set but failed match against \"{}\"",
                        path,
                        paths::REGEX_WORK_IDENT.as_str()
                    )
                });

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work(
                                            param_ident,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWorkEdit - GET /work/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_WORK_EDIT_EDIT_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WORK_EDIT_EDIT_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WORK_EDIT_EDIT_ID in set but failed match against \"{}\"", path, paths::REGEX_WORK_EDIT_EDIT_ID.as_str())
                    );

                let param_edit_id = match percent_encoding::percent_decode(path_params["edit_id"].as_bytes()).decode_utf8() {
                    Ok(param_edit_id) => match param_edit_id.parse::<String>() {
                        Ok(param_edit_id) => param_edit_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter edit_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["edit_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work_edit(
                                            param_edit_id,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkEditResponse::FoundEdit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_EDIT_FOUND_EDIT"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkEditResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_EDIT_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkEditResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_EDIT_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkEditResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_EDIT_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWorkHistory - GET /work/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_HISTORY) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WORK_IDENT_HISTORY
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WORK_IDENT_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_WORK_IDENT_HISTORY.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_limit = query_params
                    .iter()
                    .filter(|e| e.0 == "limit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_limit = param_limit.and_then(|param_limit| param_limit.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work_history(
                                            param_ident,
                                            param_limit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkHistoryResponse::FoundEntityHistory
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_HISTORY_FOUND_ENTITY_HISTORY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkHistoryResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_HISTORY_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkHistoryResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_HISTORY_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkHistoryResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_HISTORY_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWorkRedirects - GET /work/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_REDIRECTS) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WORK_IDENT_REDIRECTS
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WORK_IDENT_REDIRECTS in set but failed match against \"{}\"", path, paths::REGEX_WORK_IDENT_REDIRECTS.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work_redirects(
                                            param_ident,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkRedirectsResponse::FoundEntityRedirects
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REDIRECTS_FOUND_ENTITY_REDIRECTS"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRedirectsResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REDIRECTS_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRedirectsResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REDIRECTS_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRedirectsResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REDIRECTS_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWorkReleases - GET /work/{ident}/releases
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_RELEASES) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WORK_IDENT_RELEASES
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WORK_IDENT_RELEASES in set but failed match against \"{}\"", path, paths::REGEX_WORK_IDENT_RELEASES.as_str())
                    );

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work_releases(
                                            param_ident,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkReleasesResponse::Found
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_RELEASES_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkReleasesResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_RELEASES_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkReleasesResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_RELEASES_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkReleasesResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_RELEASES_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // GetWorkRevision - GET /work/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_WORK_REV_REV_ID) => {
                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_WORK_REV_REV_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE WORK_REV_REV_ID in set but failed match against \"{}\"", path, paths::REGEX_WORK_REV_REV_ID.as_str())
                    );

                let param_rev_id = match percent_encoding::percent_decode(path_params["rev_id"].as_bytes()).decode_utf8() {
                    Ok(param_rev_id) => match param_rev_id.parse::<String>() {
                        Ok(param_rev_id) => param_rev_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter rev_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["rev_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.get_work_revision(
                                            param_rev_id,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWorkRevisionResponse::FoundEntityRevision
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REVISION_FOUND_ENTITY_REVISION"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRevisionResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REVISION_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRevisionResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REVISION_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                GetWorkRevisionResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for GET_WORK_REVISION_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // LookupContainer - GET /container/lookup
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_LOOKUP) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_issnl = query_params
                    .iter()
                    .filter(|e| e.0 == "issnl")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_issnl = param_issnl.and_then(|param_issnl| param_issnl.parse().ok());
                let param_wikidata_qid = query_params
                    .iter()
                    .filter(|e| e.0 == "wikidata_qid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_wikidata_qid = param_wikidata_qid
                    .and_then(|param_wikidata_qid| param_wikidata_qid.parse().ok());
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.lookup_container(
                                            param_issnl,
                                            param_wikidata_qid,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LookupContainerResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CONTAINER_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupContainerResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CONTAINER_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupContainerResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CONTAINER_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupContainerResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CONTAINER_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // LookupCreator - GET /creator/lookup
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_LOOKUP) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_orcid = query_params
                    .iter()
                    .filter(|e| e.0 == "orcid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_orcid = param_orcid.and_then(|param_orcid| param_orcid.parse().ok());
                let param_wikidata_qid = query_params
                    .iter()
                    .filter(|e| e.0 == "wikidata_qid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_wikidata_qid = param_wikidata_qid
                    .and_then(|param_wikidata_qid| param_wikidata_qid.parse().ok());
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.lookup_creator(
                                            param_orcid,
                                            param_wikidata_qid,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LookupCreatorResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CREATOR_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupCreatorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CREATOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupCreatorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CREATOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupCreatorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_CREATOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // LookupFile - GET /file/lookup
            &hyper::Method::GET if path.matched(paths::ID_FILE_LOOKUP) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_md5 = query_params
                    .iter()
                    .filter(|e| e.0 == "md5")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_md5 = param_md5.and_then(|param_md5| param_md5.parse().ok());
                let param_sha1 = query_params
                    .iter()
                    .filter(|e| e.0 == "sha1")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_sha1 = param_sha1.and_then(|param_sha1| param_sha1.parse().ok());
                let param_sha256 = query_params
                    .iter()
                    .filter(|e| e.0 == "sha256")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_sha256 = param_sha256.and_then(|param_sha256| param_sha256.parse().ok());
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.lookup_file(
                                            param_md5,
                                            param_sha1,
                                            param_sha256,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LookupFileResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_FILE_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupFileResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_FILE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupFileResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_FILE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupFileResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_FILE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // LookupRelease - GET /release/lookup
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_LOOKUP) => {
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_doi = query_params
                    .iter()
                    .filter(|e| e.0 == "doi")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_doi = param_doi.and_then(|param_doi| param_doi.parse().ok());
                let param_wikidata_qid = query_params
                    .iter()
                    .filter(|e| e.0 == "wikidata_qid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_wikidata_qid = param_wikidata_qid
                    .and_then(|param_wikidata_qid| param_wikidata_qid.parse().ok());
                let param_isbn13 = query_params
                    .iter()
                    .filter(|e| e.0 == "isbn13")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_isbn13 = param_isbn13.and_then(|param_isbn13| param_isbn13.parse().ok());
                let param_pmid = query_params
                    .iter()
                    .filter(|e| e.0 == "pmid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_pmid = param_pmid.and_then(|param_pmid| param_pmid.parse().ok());
                let param_pmcid = query_params
                    .iter()
                    .filter(|e| e.0 == "pmcid")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_pmcid = param_pmcid.and_then(|param_pmcid| param_pmcid.parse().ok());
                let param_core = query_params
                    .iter()
                    .filter(|e| e.0 == "core")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_core = param_core.and_then(|param_core| param_core.parse().ok());
                let param_arxiv = query_params
                    .iter()
                    .filter(|e| e.0 == "arxiv")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_arxiv = param_arxiv.and_then(|param_arxiv| param_arxiv.parse().ok());
                let param_jstor = query_params
                    .iter()
                    .filter(|e| e.0 == "jstor")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_jstor = param_jstor.and_then(|param_jstor| param_jstor.parse().ok());
                let param_ark = query_params
                    .iter()
                    .filter(|e| e.0 == "ark")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_ark = param_ark.and_then(|param_ark| param_ark.parse().ok());
                let param_mag = query_params
                    .iter()
                    .filter(|e| e.0 == "mag")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_mag = param_mag.and_then(|param_mag| param_mag.parse().ok());
                let param_expand = query_params
                    .iter()
                    .filter(|e| e.0 == "expand")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_expand = param_expand.and_then(|param_expand| param_expand.parse().ok());
                let param_hide = query_params
                    .iter()
                    .filter(|e| e.0 == "hide")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_hide = param_hide.and_then(|param_hide| param_hide.parse().ok());

                Box::new({
                    {
                        {
                            Box::new(
                                    api_impl.lookup_release(
                                            param_doi,
                                            param_wikidata_qid,
                                            param_isbn13,
                                            param_pmid,
                                            param_pmcid,
                                            param_core,
                                            param_arxiv,
                                            param_jstor,
                                            param_ark,
                                            param_mag,
                                            param_expand,
                                            param_hide,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LookupReleaseResponse::FoundEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_RELEASE_FOUND_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupReleaseResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_RELEASE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupReleaseResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_RELEASE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                LookupReleaseResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LOOKUP_RELEASE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                        }
                    }
                }) as Self::Future
            }

            // UpdateContainer - PUT /editgroup/{editgroup_id}/container/{ident}
            &hyper::Method::PUT
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::ContainerEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_container(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateContainerResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateContainerResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateContainerResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateContainerResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateContainerResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateContainerResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CONTAINER_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateCreator - PUT /editgroup/{editgroup_id}/creator/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_CREATOR_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::CreatorEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_creator(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateCreatorResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateCreatorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateCreatorResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateCreatorResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateCreatorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateCreatorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_CREATOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateEditgroup - PUT /editgroup/{editgroup_id}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params =
                    form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes())
                        .collect::<Vec<_>>();
                let param_submit = query_params
                    .iter()
                    .filter(|e| e.0 == "submit")
                    .map(|e| e.1.to_owned())
                    .nth(0);
                let param_submit = param_submit.and_then(|param_submit| param_submit.parse().ok());

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_editgroup: Option<models::Editgroup> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_editgroup) => param_editgroup,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter editgroup - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter editgroup due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_editgroup = match param_editgroup {
                                    Some(param_editgroup) => param_editgroup,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter editgroup"))
                                                        .expect("Unable to create Bad Request response for missing body parameter editgroup"))),
                                };

                                Box::new(
                                    api_impl.update_editgroup(
                                            param_editgroup_id,
                                            param_editgroup,
                                            param_submit,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateEditgroupResponse::UpdatedEditgroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_UPDATED_EDITGROUP"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditgroupResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditgroupResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditgroupResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditgroupResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditgroupResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITGROUP_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter editgroup: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter editgroup"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateEditor - PUT /editor/{editor_id}
            &hyper::Method::PUT if path.matched(paths::ID_EDITOR_EDITOR_ID) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITOR_EDITOR_ID
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITOR_EDITOR_ID in set but failed match against \"{}\"", path, paths::REGEX_EDITOR_EDITOR_ID.as_str())
                    );

                let param_editor_id = match percent_encoding::percent_decode(path_params["editor_id"].as_bytes()).decode_utf8() {
                    Ok(param_editor_id) => match param_editor_id.parse::<String>() {
                        Ok(param_editor_id) => param_editor_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editor_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editor_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_editor: Option<models::Editor> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_editor) => param_editor,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter editor - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter editor due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_editor = match param_editor {
                                    Some(param_editor) => param_editor,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter editor"))
                                                        .expect("Unable to create Bad Request response for missing body parameter editor"))),
                                };

                                Box::new(
                                    api_impl.update_editor(
                                            param_editor_id,
                                            param_editor,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateEditorResponse::UpdatedEditor
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_UPDATED_EDITOR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditorResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditorResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditorResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditorResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateEditorResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_EDITOR_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter editor: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter editor"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateFile - PUT /editgroup/{editgroup_id}/file/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::FileEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_file(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateFileResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFileResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFileResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFileResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFileResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFileResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateFileset - PUT /editgroup/{editgroup_id}/fileset/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_FILESET_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_FILESET_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::FilesetEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_fileset(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateFilesetResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFilesetResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFilesetResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFilesetResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFilesetResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateFilesetResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_FILESET_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateRelease - PUT /editgroup/{editgroup_id}/release/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_RELEASE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::ReleaseEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_release(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateReleaseResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateReleaseResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateReleaseResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateReleaseResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateReleaseResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateReleaseResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_RELEASE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateWebcapture - PUT /editgroup/{editgroup_id}/webcapture/{ident}
            &hyper::Method::PUT
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT) =>
            {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::WebcaptureEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_webcapture(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateWebcaptureResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWebcaptureResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWebcaptureResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWebcaptureResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWebcaptureResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWebcaptureResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WEBCAPTURE_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            // UpdateWork - PUT /editgroup/{editgroup_id}/work/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT) => {
                {
                    let authorization = match (&context as &dyn Has<Option<Authorization>>).get() {
                        &Some(ref authorization) => authorization,
                        &None => {
                            return Box::new(future::ok(
                                Response::builder()
                                    .status(StatusCode::FORBIDDEN)
                                    .body(Body::from("Unauthenticated"))
                                    .expect("Unable to create Authentication Forbidden response"),
                            ))
                        }
                    };
                }

                // Path parameters
                let path: &str = &uri.path().to_string();
                let path_params =
                    paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_IDENT
                    .captures(&path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE EDITGROUP_EDITGROUP_ID_WORK_IDENT in set but failed match against \"{}\"", path, paths::REGEX_EDITGROUP_EDITGROUP_ID_WORK_IDENT.as_str())
                    );

                let param_editgroup_id = match percent_encoding::percent_decode(path_params["editgroup_id"].as_bytes()).decode_utf8() {
                    Ok(param_editgroup_id) => match param_editgroup_id.parse::<String>() {
                        Ok(param_editgroup_id) => param_editgroup_id,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter editgroup_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["editgroup_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                let param_ident = match percent_encoding::percent_decode(path_params["ident"].as_bytes()).decode_utf8() {
                    Ok(param_ident) => match param_ident.parse::<String>() {
                        Ok(param_ident) => param_ident,
                        Err(e) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ident: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter"))),
                    },
                    Err(_) => return Box::new(future::ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ident"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode")))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                Box::new(body.concat2()
                    .then(move |result| -> Self::Future {
                        match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_entity: Option<models::WorkEntity> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_entity) => param_entity,
                                        Err(e) => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter entity - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter entity due to schema"))),
                                    }
                                } else {
                                    None
                                };
                                let param_entity = match param_entity {
                                    Some(param_entity) => param_entity,
                                    None => return Box::new(future::ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter entity"))
                                                        .expect("Unable to create Bad Request response for missing body parameter entity"))),
                                };

                                Box::new(
                                    api_impl.update_work(
                                            param_editgroup_id,
                                            param_ident,
                                            param_entity,
                                        &context
                                    ).then(move |result| {
                                        let mut response = Response::new(Body::empty());
                                        response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().to_string().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateWorkResponse::UpdatedEntity
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_UPDATED_ENTITY"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWorkResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_BAD_REQUEST"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWorkResponse::NotAuthorized
                                                    {
                                                        body,
                                                        www_authenticate
                                                    }
                                                => {
                                                    let www_authenticate = match header::IntoHeaderValue(www_authenticate).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return future::ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Body::from(format!("An internal server error occurred handling www_authenticate header - {}", e)))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("www_authenticate"),
                                                        www_authenticate
                                                    );
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_NOT_AUTHORIZED"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWorkResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_FORBIDDEN"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWorkResponse::NotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_NOT_FOUND"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                                UpdateWorkResponse::GenericError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UPDATE_WORK_GENERIC_ERROR"));
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        future::ok(response)
                                    }
                                ))
                            },
                            Err(e) => Box::new(future::ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter entity: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter entity"))),
                        }
                    })
                ) as Self::Future
            }

            _ if path.matched(paths::ID_AUTH_CHECK) => method_not_allowed(),
            _ if path.matched(paths::ID_AUTH_OIDC) => method_not_allowed(),
            _ if path.matched(paths::ID_AUTH_TOKEN_EDITOR_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CHANGELOG) => method_not_allowed(),
            _ if path.matched(paths::ID_CHANGELOG_INDEX) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_LOOKUP) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_CONTAINER_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_LOOKUP) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CREATOR_IDENT_RELEASES) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_CONTAINER_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_CREATOR_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_FILE_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_FILESET_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_RELEASE_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_WEBCAPTURE_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_AUTO_WORK_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_REVIEWABLE) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ACCEPT) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATION) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID) => {
                method_not_allowed()
            }
            _ if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITOR_EDITOR_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITOR_EDITOR_ID_ANNOTATIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_EDITOR_EDITOR_ID_EDITGROUPS) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_LOOKUP) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_FILE_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_FILESET_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_FILESET_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_FILESET_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_FILESET_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_FILESET_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_LOOKUP) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT_FILES) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT_FILESETS) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_RELEASE_IDENT_WEBCAPTURES) => method_not_allowed(),
            _ if path.matched(paths::ID_WEBCAPTURE_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_WEBCAPTURE_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_WEBCAPTURE_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_WEBCAPTURE_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_WEBCAPTURE_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_EDIT_EDIT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_REV_REV_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_IDENT) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_IDENT_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_IDENT_REDIRECTS) => method_not_allowed(),
            _ if path.matched(paths::ID_WORK_IDENT_RELEASES) => method_not_allowed(),
            _ => Box::new(future::ok(
                Response::builder()
                    .status(StatusCode::NOT_FOUND)
                    .body(Body::empty())
                    .expect("Unable to create Not Found response"),
            )) as Self::Future,
        }
    }
}

impl<T, C> Clone for Service<T, C>
where
    T: Clone,
{
    fn clone(&self) -> Self {
        Service {
            api_impl: self.api_impl.clone(),
            marker: self.marker.clone(),
        }
    }
}

/// Request parser for `Api`.
pub struct ApiRequestParser;
impl<T> RequestParser<T> for ApiRequestParser {
    fn parse_operation_id(request: &Request<T>) -> Result<&'static str, ()> {
        let path = paths::GLOBAL_REGEX_SET.matches(request.uri().path());
        match request.method() {
            // AcceptEditgroup - POST /editgroup/{editgroup_id}/accept
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ACCEPT) => {
                Ok("AcceptEditgroup")
            }
            // AuthCheck - GET /auth/check
            &hyper::Method::GET if path.matched(paths::ID_AUTH_CHECK) => Ok("AuthCheck"),
            // AuthOidc - POST /auth/oidc
            &hyper::Method::POST if path.matched(paths::ID_AUTH_OIDC) => Ok("AuthOidc"),
            // CreateAuthToken - POST /auth/token/{editor_id}
            &hyper::Method::POST if path.matched(paths::ID_AUTH_TOKEN_EDITOR_ID) => {
                Ok("CreateAuthToken")
            }
            // CreateContainer - POST /editgroup/{editgroup_id}/container
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER) => {
                Ok("CreateContainer")
            }
            // CreateContainerAutoBatch - POST /editgroup/auto/container/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_CONTAINER_BATCH) => {
                Ok("CreateContainerAutoBatch")
            }
            // CreateCreator - POST /editgroup/{editgroup_id}/creator
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR) => {
                Ok("CreateCreator")
            }
            // CreateCreatorAutoBatch - POST /editgroup/auto/creator/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_CREATOR_BATCH) => {
                Ok("CreateCreatorAutoBatch")
            }
            // CreateEditgroup - POST /editgroup
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP) => Ok("CreateEditgroup"),
            // CreateEditgroupAnnotation - POST /editgroup/{editgroup_id}/annotation
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATION) => {
                Ok("CreateEditgroupAnnotation")
            }
            // CreateFile - POST /editgroup/{editgroup_id}/file
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE) => {
                Ok("CreateFile")
            }
            // CreateFileAutoBatch - POST /editgroup/auto/file/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_FILE_BATCH) => {
                Ok("CreateFileAutoBatch")
            }
            // CreateFileset - POST /editgroup/{editgroup_id}/fileset
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET) => {
                Ok("CreateFileset")
            }
            // CreateFilesetAutoBatch - POST /editgroup/auto/fileset/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_FILESET_BATCH) => {
                Ok("CreateFilesetAutoBatch")
            }
            // CreateRelease - POST /editgroup/{editgroup_id}/release
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE) => {
                Ok("CreateRelease")
            }
            // CreateReleaseAutoBatch - POST /editgroup/auto/release/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_RELEASE_BATCH) => {
                Ok("CreateReleaseAutoBatch")
            }
            // CreateWebcapture - POST /editgroup/{editgroup_id}/webcapture
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE) => {
                Ok("CreateWebcapture")
            }
            // CreateWebcaptureAutoBatch - POST /editgroup/auto/webcapture/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_WEBCAPTURE_BATCH) => {
                Ok("CreateWebcaptureAutoBatch")
            }
            // CreateWork - POST /editgroup/{editgroup_id}/work
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK) => {
                Ok("CreateWork")
            }
            // CreateWorkAutoBatch - POST /editgroup/auto/work/batch
            &hyper::Method::POST if path.matched(paths::ID_EDITGROUP_AUTO_WORK_BATCH) => {
                Ok("CreateWorkAutoBatch")
            }
            // DeleteContainer - DELETE /editgroup/{editgroup_id}/container/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT) =>
            {
                Ok("DeleteContainer")
            }
            // DeleteContainerEdit - DELETE /editgroup/{editgroup_id}/container/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_EDIT_EDIT_ID) =>
            {
                Ok("DeleteContainerEdit")
            }
            // DeleteCreator - DELETE /editgroup/{editgroup_id}/creator/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT) =>
            {
                Ok("DeleteCreator")
            }
            // DeleteCreatorEdit - DELETE /editgroup/{editgroup_id}/creator/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_EDIT_EDIT_ID) =>
            {
                Ok("DeleteCreatorEdit")
            }
            // DeleteFile - DELETE /editgroup/{editgroup_id}/file/{ident}
            &hyper::Method::DELETE if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT) => {
                Ok("DeleteFile")
            }
            // DeleteFileEdit - DELETE /editgroup/{editgroup_id}/file/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_EDIT_EDIT_ID) =>
            {
                Ok("DeleteFileEdit")
            }
            // DeleteFileset - DELETE /editgroup/{editgroup_id}/fileset/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT) =>
            {
                Ok("DeleteFileset")
            }
            // DeleteFilesetEdit - DELETE /editgroup/{editgroup_id}/fileset/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_EDIT_EDIT_ID) =>
            {
                Ok("DeleteFilesetEdit")
            }
            // DeleteRelease - DELETE /editgroup/{editgroup_id}/release/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT) =>
            {
                Ok("DeleteRelease")
            }
            // DeleteReleaseEdit - DELETE /editgroup/{editgroup_id}/release/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_EDIT_EDIT_ID) =>
            {
                Ok("DeleteReleaseEdit")
            }
            // DeleteWebcapture - DELETE /editgroup/{editgroup_id}/webcapture/{ident}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT) =>
            {
                Ok("DeleteWebcapture")
            }
            // DeleteWebcaptureEdit - DELETE /editgroup/{editgroup_id}/webcapture/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_EDIT_EDIT_ID) =>
            {
                Ok("DeleteWebcaptureEdit")
            }
            // DeleteWork - DELETE /editgroup/{editgroup_id}/work/{ident}
            &hyper::Method::DELETE if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT) => {
                Ok("DeleteWork")
            }
            // DeleteWorkEdit - DELETE /editgroup/{editgroup_id}/work/edit/{edit_id}
            &hyper::Method::DELETE
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_EDIT_EDIT_ID) =>
            {
                Ok("DeleteWorkEdit")
            }
            // GetChangelog - GET /changelog
            &hyper::Method::GET if path.matched(paths::ID_CHANGELOG) => Ok("GetChangelog"),
            // GetChangelogEntry - GET /changelog/{index}
            &hyper::Method::GET if path.matched(paths::ID_CHANGELOG_INDEX) => {
                Ok("GetChangelogEntry")
            }
            // GetContainer - GET /container/{ident}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT) => Ok("GetContainer"),
            // GetContainerEdit - GET /container/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_EDIT_EDIT_ID) => {
                Ok("GetContainerEdit")
            }
            // GetContainerHistory - GET /container/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT_HISTORY) => {
                Ok("GetContainerHistory")
            }
            // GetContainerRedirects - GET /container/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_IDENT_REDIRECTS) => {
                Ok("GetContainerRedirects")
            }
            // GetContainerRevision - GET /container/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_REV_REV_ID) => {
                Ok("GetContainerRevision")
            }
            // GetCreator - GET /creator/{ident}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT) => Ok("GetCreator"),
            // GetCreatorEdit - GET /creator/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_EDIT_EDIT_ID) => {
                Ok("GetCreatorEdit")
            }
            // GetCreatorHistory - GET /creator/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_HISTORY) => {
                Ok("GetCreatorHistory")
            }
            // GetCreatorRedirects - GET /creator/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_REDIRECTS) => {
                Ok("GetCreatorRedirects")
            }
            // GetCreatorReleases - GET /creator/{ident}/releases
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_IDENT_RELEASES) => {
                Ok("GetCreatorReleases")
            }
            // GetCreatorRevision - GET /creator/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_REV_REV_ID) => {
                Ok("GetCreatorRevision")
            }
            // GetEditgroup - GET /editgroup/{editgroup_id}
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID) => {
                Ok("GetEditgroup")
            }
            // GetEditgroupAnnotations - GET /editgroup/{editgroup_id}/annotations
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_ANNOTATIONS) => {
                Ok("GetEditgroupAnnotations")
            }
            // GetEditgroupsReviewable - GET /editgroup/reviewable
            &hyper::Method::GET if path.matched(paths::ID_EDITGROUP_REVIEWABLE) => {
                Ok("GetEditgroupsReviewable")
            }
            // GetEditor - GET /editor/{editor_id}
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID) => Ok("GetEditor"),
            // GetEditorAnnotations - GET /editor/{editor_id}/annotations
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID_ANNOTATIONS) => {
                Ok("GetEditorAnnotations")
            }
            // GetEditorEditgroups - GET /editor/{editor_id}/editgroups
            &hyper::Method::GET if path.matched(paths::ID_EDITOR_EDITOR_ID_EDITGROUPS) => {
                Ok("GetEditorEditgroups")
            }
            // GetFile - GET /file/{ident}
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT) => Ok("GetFile"),
            // GetFileEdit - GET /file/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_FILE_EDIT_EDIT_ID) => Ok("GetFileEdit"),
            // GetFileHistory - GET /file/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT_HISTORY) => {
                Ok("GetFileHistory")
            }
            // GetFileRedirects - GET /file/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_FILE_IDENT_REDIRECTS) => {
                Ok("GetFileRedirects")
            }
            // GetFileRevision - GET /file/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_FILE_REV_REV_ID) => Ok("GetFileRevision"),
            // GetFileset - GET /fileset/{ident}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT) => Ok("GetFileset"),
            // GetFilesetEdit - GET /fileset/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_EDIT_EDIT_ID) => {
                Ok("GetFilesetEdit")
            }
            // GetFilesetHistory - GET /fileset/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT_HISTORY) => {
                Ok("GetFilesetHistory")
            }
            // GetFilesetRedirects - GET /fileset/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_FILESET_IDENT_REDIRECTS) => {
                Ok("GetFilesetRedirects")
            }
            // GetFilesetRevision - GET /fileset/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_FILESET_REV_REV_ID) => {
                Ok("GetFilesetRevision")
            }
            // GetRelease - GET /release/{ident}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT) => Ok("GetRelease"),
            // GetReleaseEdit - GET /release/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_EDIT_EDIT_ID) => {
                Ok("GetReleaseEdit")
            }
            // GetReleaseFiles - GET /release/{ident}/files
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_FILES) => {
                Ok("GetReleaseFiles")
            }
            // GetReleaseFilesets - GET /release/{ident}/filesets
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_FILESETS) => {
                Ok("GetReleaseFilesets")
            }
            // GetReleaseHistory - GET /release/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_HISTORY) => {
                Ok("GetReleaseHistory")
            }
            // GetReleaseRedirects - GET /release/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_REDIRECTS) => {
                Ok("GetReleaseRedirects")
            }
            // GetReleaseRevision - GET /release/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_REV_REV_ID) => {
                Ok("GetReleaseRevision")
            }
            // GetReleaseWebcaptures - GET /release/{ident}/webcaptures
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_IDENT_WEBCAPTURES) => {
                Ok("GetReleaseWebcaptures")
            }
            // GetWebcapture - GET /webcapture/{ident}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT) => Ok("GetWebcapture"),
            // GetWebcaptureEdit - GET /webcapture/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_EDIT_EDIT_ID) => {
                Ok("GetWebcaptureEdit")
            }
            // GetWebcaptureHistory - GET /webcapture/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT_HISTORY) => {
                Ok("GetWebcaptureHistory")
            }
            // GetWebcaptureRedirects - GET /webcapture/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_IDENT_REDIRECTS) => {
                Ok("GetWebcaptureRedirects")
            }
            // GetWebcaptureRevision - GET /webcapture/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_WEBCAPTURE_REV_REV_ID) => {
                Ok("GetWebcaptureRevision")
            }
            // GetWork - GET /work/{ident}
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT) => Ok("GetWork"),
            // GetWorkEdit - GET /work/edit/{edit_id}
            &hyper::Method::GET if path.matched(paths::ID_WORK_EDIT_EDIT_ID) => Ok("GetWorkEdit"),
            // GetWorkHistory - GET /work/{ident}/history
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_HISTORY) => {
                Ok("GetWorkHistory")
            }
            // GetWorkRedirects - GET /work/{ident}/redirects
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_REDIRECTS) => {
                Ok("GetWorkRedirects")
            }
            // GetWorkReleases - GET /work/{ident}/releases
            &hyper::Method::GET if path.matched(paths::ID_WORK_IDENT_RELEASES) => {
                Ok("GetWorkReleases")
            }
            // GetWorkRevision - GET /work/rev/{rev_id}
            &hyper::Method::GET if path.matched(paths::ID_WORK_REV_REV_ID) => Ok("GetWorkRevision"),
            // LookupContainer - GET /container/lookup
            &hyper::Method::GET if path.matched(paths::ID_CONTAINER_LOOKUP) => {
                Ok("LookupContainer")
            }
            // LookupCreator - GET /creator/lookup
            &hyper::Method::GET if path.matched(paths::ID_CREATOR_LOOKUP) => Ok("LookupCreator"),
            // LookupFile - GET /file/lookup
            &hyper::Method::GET if path.matched(paths::ID_FILE_LOOKUP) => Ok("LookupFile"),
            // LookupRelease - GET /release/lookup
            &hyper::Method::GET if path.matched(paths::ID_RELEASE_LOOKUP) => Ok("LookupRelease"),
            // UpdateContainer - PUT /editgroup/{editgroup_id}/container/{ident}
            &hyper::Method::PUT
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CONTAINER_IDENT) =>
            {
                Ok("UpdateContainer")
            }
            // UpdateCreator - PUT /editgroup/{editgroup_id}/creator/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_CREATOR_IDENT) => {
                Ok("UpdateCreator")
            }
            // UpdateEditgroup - PUT /editgroup/{editgroup_id}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID) => {
                Ok("UpdateEditgroup")
            }
            // UpdateEditor - PUT /editor/{editor_id}
            &hyper::Method::PUT if path.matched(paths::ID_EDITOR_EDITOR_ID) => Ok("UpdateEditor"),
            // UpdateFile - PUT /editgroup/{editgroup_id}/file/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILE_IDENT) => {
                Ok("UpdateFile")
            }
            // UpdateFileset - PUT /editgroup/{editgroup_id}/fileset/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_FILESET_IDENT) => {
                Ok("UpdateFileset")
            }
            // UpdateRelease - PUT /editgroup/{editgroup_id}/release/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_RELEASE_IDENT) => {
                Ok("UpdateRelease")
            }
            // UpdateWebcapture - PUT /editgroup/{editgroup_id}/webcapture/{ident}
            &hyper::Method::PUT
                if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WEBCAPTURE_IDENT) =>
            {
                Ok("UpdateWebcapture")
            }
            // UpdateWork - PUT /editgroup/{editgroup_id}/work/{ident}
            &hyper::Method::PUT if path.matched(paths::ID_EDITGROUP_EDITGROUP_ID_WORK_IDENT) => {
                Ok("UpdateWork")
            }
            _ => Err(()),
        }
    }
}
